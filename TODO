1. Add support for const stack variables
2. Add support for function pointers. Currently, if a function pointer is stored
   on the stack/heap and included in a checkpoint it won't be restored to the
   correct address based on the actual function it was pointing at... This is
   not an easy problem.
3. Support resuming from inside functions that are passed directly as parameters
   to another function (e.g. resume from bar when you call foo(bar())). The
   simplest way to fix this is probably by inserting temporary variables before
   the function call. Replacing their use in the AST? this would require an
   extension to the current line number modification framework to allow the
   extension of single line statements to multi-line statements. This also seems
   to apply to function calls made within for loops, while loops, etc.
4. We currently get the function pointer of the current function as a way of
   verifying that the callee is using alias data intended for it (and that it
   isn't passing through some arbitrary 3rd party library first). However, this
   stops working if a local variable hides the function pointer inside the
   callee, e.g.:

       void foo(int foo) { ... }

   To fix this, we can do a renaming of the local variable during the code
   generation phase.
5. We currently require that there be some kind of statement before an OMP
   pragma for us to find and insert after.
6. Add support for dynamically sized stack arrays, eg. int arr[num_threads].
7. Don't support function-local static variables (splitting variable declaration
   from assignment breaks them).
8. Don't support directly returning function call results.
9. There is some weirdness around getting into NPM mode in the first place. We
   don’t really want to instrument every single function call with this logic.
   Right now what it does is check if each function being called that is within
   the same compilation unit has been converted to NPM, and if it is the call is
   translated at runtime to call the NPM version. However, this only works if
   the main body of the computation is beneath a function call that is
   convertible to NPM and is inside the same compilation unit as its caller.
   some basic improvements would be to just do this analysis for every call in
   main, or something like that. but if you have a lot of jumping across
   compilation units, the function calls will never have been converted to NPM
   at compile time so we’ll never get into NPM mode (even though the NPM
   function pointers are available).
