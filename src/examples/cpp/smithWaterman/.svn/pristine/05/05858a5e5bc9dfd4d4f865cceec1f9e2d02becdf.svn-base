#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <time.h>
#include <hc.h>

#define GAP_PENALTY -1
#define TRANSITION_PENALTY -2
#define TRANSVERSION_PENALTY -4
#define MATCH 2

#define DEBUG 0

#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#define DIAG_INDEX(r,c) ((n_tiles_y - 1) + (c - r))
#define DDDF_GUID DDDF_GUID_DIAG

signed char* string_1;
signed char* string_2;

int strlen_1;
int strlen_2;

int tile_width;
int tile_height;

int outer_tile_width;
int outer_tile_height;

int n_tiles_x;
int n_tiles_y;

int n_outer_tiles_x;
int n_outer_tiles_y;

int outer_tiles_length_x; // number of inner tiles on outer tile's x dimension
int outer_tiles_length_y; // number of inner tiles on outer tile's y dimension

int ** tile_edges_x;
int ** tile_edges_y;
int * tile_diag;

int *** worker_tiles;

int nthreads;
int comm_size, comm_rank;
struct timeval begin,end;

size_t dsizes[3];

typedef struct TDF {
	DDF_t * diag;
	DDF_t * rcol;
	DDF_t * brow;
} TDF_t;

TDF_t *** tdfArray;

int DDDF_GUID_DIAG(int r, int c) { return (0*(n_tiles_x * n_tiles_y) + (r * n_tiles_x + c)); }
int DDDF_GUID_RCOL(int r, int c) { return (1*(n_tiles_x * n_tiles_y) + (r * n_tiles_x + c)); }
int DDDF_GUID_BROW(int r, int c) { return (2*(n_tiles_x * n_tiles_y) + (r * n_tiles_x + c)); }

#if 0
int DDF_HOME(int guid) { 
	int normalized_guid = guid % (n_tiles_x * n_tiles_y); // normalizes diag, brow, rcol guids
	int inner_r = normalized_guid / n_tiles_x;
	int inner_c = normalized_guid % n_tiles_x;
	if (inner_r == 0 || inner_c == 0) return comm_rank;
	int outer_r = (inner_r-1) / outer_tiles_length_y;
	int outer_c = (inner_c-1) / outer_tiles_length_x;
	int outer_guid = outer_r * n_outer_tiles_x + outer_c;
	return (outer_guid % comm_size); //block cyclic distribution
	//return (outer_c % comm_size); //column cyclic distribution
}
#endif

/*sagnak was here begin */
#define DDF_HOME(guid) diagonal_cyclic_distribution_function(guid)
//#define DDF_HOME(guid) diagonal_block_cyclic_distribution_function(guid)
//#define DDF_HOME(guid) column_cyclic_distribution_function (guid)
//#define DDF_HOME(guid) row_cyclic_distribution_function (guid)

static int column_cyclic_distribution_function ( int guid ) {
	int normalized_guid = guid % (n_tiles_x * n_tiles_y); // normalizes diag, brow, rcol guids
	int inner_r = normalized_guid / n_tiles_x;
	int inner_c = normalized_guid % n_tiles_x;
	if (inner_r == 0 || inner_c == 0) return comm_rank;
	int outer_r = (inner_r-1) / outer_tiles_length_y;
	int outer_c = (inner_c-1) / outer_tiles_length_x;
    
    int j = outer_c;

    return j % comm_size;
}

static int row_cyclic_distribution_function ( int guid ) {
	int normalized_guid = guid % (n_tiles_x * n_tiles_y); // normalizes diag, brow, rcol guids
	int inner_r = normalized_guid / n_tiles_x;
	int inner_c = normalized_guid % n_tiles_x;
	if (inner_r == 0 || inner_c == 0) return comm_rank;
	int outer_r = (inner_r-1) / outer_tiles_length_y;
	int outer_c = (inner_c-1) / outer_tiles_length_x;

    int i = outer_r;

    return i % comm_size;
}

static int diagonal_cyclic_distribution_function ( int guid ) {
	int normalized_guid = guid % (n_tiles_x * n_tiles_y); // normalizes diag, brow, rcol guids
	int inner_r = normalized_guid / n_tiles_x;
	int inner_c = normalized_guid % n_tiles_x;
	if (inner_r == 0 || inner_c == 0) return comm_rank;
	int outer_r = (inner_r-1) / outer_tiles_length_y;
	int outer_c = (inner_c-1) / outer_tiles_length_x;
    
    int i = outer_r;
    int j = outer_c;

    int n_left_complete_diagonals = -1; 
    int n_complete_diagonals = -1; 
    int n_right_complete_diagonals = -1; 
    int index_in_diagonal = -1; 

    int first_complete_diagonal_index = (n_outer_tiles_x > n_outer_tiles_y) ? n_outer_tiles_y - 1: n_outer_tiles_x - 1;
    int last_complete_diagonal_index = (n_outer_tiles_x > n_outer_tiles_y) ? n_outer_tiles_x - 1 : n_outer_tiles_y - 1;
    int diagonal_size = (n_outer_tiles_x > n_outer_tiles_y) ? n_outer_tiles_y : n_outer_tiles_x;

    int on_diagonal = i+j;

    if ( on_diagonal <= first_complete_diagonal_index ) { // on the top left corner or the first diagonal
        n_left_complete_diagonals = i+j;
        n_complete_diagonals = 0;
        n_right_complete_diagonals = 0;
        index_in_diagonal = i;
    } else if ( on_diagonal <= last_complete_diagonal_index ) { // on the complete diagonals
        n_left_complete_diagonals = first_complete_diagonal_index;
        n_complete_diagonals = on_diagonal - first_complete_diagonal_index; // number of passed diagonals
        n_right_complete_diagonals = 0;
        index_in_diagonal = (n_outer_tiles_x > n_outer_tiles_y) ? i : i - n_complete_diagonals;
    } else {
        n_left_complete_diagonals = first_complete_diagonal_index;
        n_complete_diagonals = last_complete_diagonal_index - first_complete_diagonal_index + 1; // number of passed diagonals
        n_right_complete_diagonals = on_diagonal - last_complete_diagonal_index - 1;
        index_in_diagonal = (n_outer_tiles_x > n_outer_tiles_y) ? i - (on_diagonal - last_complete_diagonal_index) : i - (on_diagonal - first_complete_diagonal_index); 
    }   

    int offset_of_diagonal = ((n_left_complete_diagonals*(1+n_left_complete_diagonals))/2)
        + diagonal_size*n_complete_diagonals
        + ((diagonal_size-1)*diagonal_size)/2 - (((diagonal_size-n_right_complete_diagonals-1)*(diagonal_size-n_right_complete_diagonals))/2);

    return (offset_of_diagonal+index_in_diagonal) % comm_size;
}

static int diagonal_block_cyclic_distribution_function ( int guid ) {
	int normalized_guid = guid % (n_tiles_x * n_tiles_y); // normalizes diag, brow, rcol guids
	int inner_r = normalized_guid / n_tiles_x;
	int inner_c = normalized_guid % n_tiles_x;
	if (inner_r == 0 || inner_c == 0) return comm_rank;
	int outer_r = (inner_r-1) / outer_tiles_length_y;
	int outer_c = (inner_c-1) / outer_tiles_length_x;
    
    int i = outer_r;
    int j = outer_c;

    int index_in_diagonal = -1;
    int curr_diag_size = -1;
    int tiles_per_node = -1;

    int first_complete_diagonal_index = (n_outer_tiles_x > n_outer_tiles_y) ? n_outer_tiles_y - 1: n_outer_tiles_x - 1;
    int last_complete_diagonal_index = (n_outer_tiles_x > n_outer_tiles_y) ? n_outer_tiles_x - 1 : n_outer_tiles_y - 1;
    int max_diagonal_size = (n_outer_tiles_x > n_outer_tiles_y) ? n_outer_tiles_y : n_outer_tiles_x ;

    int on_diagonal = i+j;

    if ( on_diagonal <= first_complete_diagonal_index ) { // on the top left corner or the first diagonal
        curr_diag_size = i+j+1;
        index_in_diagonal = i;
    } else if ( on_diagonal <= last_complete_diagonal_index ) { // on the complete diagonals
        curr_diag_size = max_diagonal_size;
        index_in_diagonal = (n_outer_tiles_x > n_outer_tiles_y) ? i : i - on_diagonal + n_outer_tiles_x - 1;
    } else {
        curr_diag_size = max_diagonal_size - (on_diagonal - last_complete_diagonal_index);
        index_in_diagonal = (n_outer_tiles_x > n_outer_tiles_y) ? i - (on_diagonal - last_complete_diagonal_index) : i - on_diagonal + n_outer_tiles_x - 1 ;
    }

    int per_node = curr_diag_size / comm_size;
    int extra = curr_diag_size - per_node*comm_size;
    int speculated = 0;

    if (per_node) {
        speculated = -1;
        while ( index_in_diagonal >= 0 ) {
            index_in_diagonal -= per_node;
            if ( extra > 0 ) { --extra; --index_in_diagonal; }
            ++speculated;
        }
    } else {
        speculated = index_in_diagonal;
    }
    return speculated;
}

 
/*sagnak was here end*/


int DDF_SIZE(int guid) { return dsizes[guid/(n_tiles_x * n_tiles_y)]; }

enum Nucleotide {GAP=0, ADENINE, CYTOSINE, GUANINE, THYMINE};

signed char char_mapping ( char c ) {
    signed char to_be_returned = -1;
    switch(c) {
        case '_': to_be_returned = GAP; break;
        case 'A': to_be_returned = ADENINE; break;
        case 'C': to_be_returned = CYTOSINE; break;
        case 'G': to_be_returned = GUANINE; break;
        case 'T': to_be_returned = THYMINE; break;
    }
    return to_be_returned;
}

void print_matrix ( int** matrix, int n_rows, int n_columns ) {
    int i, j;
    for ( i = 0; i < n_rows; ++i ) {
        for ( j = 0; j < n_columns; ++j ) {
            fprintf(stdout, "%d ", matrix[i][j]);
        }
        fprintf(stdout, "\n");
    }
    fprintf(stdout,"--------------------------------\n");
}

static char alignment_score_matrix[5][5] =
{
    {GAP_PENALTY,GAP_PENALTY,GAP_PENALTY,GAP_PENALTY,GAP_PENALTY},
    {GAP_PENALTY,MATCH,TRANSVERSION_PENALTY,TRANSITION_PENALTY,TRANSVERSION_PENALTY},
    {GAP_PENALTY,TRANSVERSION_PENALTY, MATCH,TRANSVERSION_PENALTY,TRANSITION_PENALTY},
    {GAP_PENALTY,TRANSITION_PENALTY,TRANSVERSION_PENALTY, MATCH,TRANSVERSION_PENALTY},
    {GAP_PENALTY,TRANSVERSION_PENALTY,TRANSITION_PENALTY,TRANSVERSION_PENALTY, MATCH}
};

size_t clear_whitespaces_do_mapping ( signed char* buffer, long size ) {
    size_t non_ws_index = 0, traverse_index = 0;

    while ( traverse_index < size ) {
        char curr_char = buffer[traverse_index];
        switch ( curr_char ) {
            case 'A': case 'C': case 'G': case 'T':
                /*this used to be a copy not also does mapping*/
                buffer[non_ws_index++] = char_mapping(curr_char);
                break;
        }
        ++traverse_index;
    }
    return non_ws_index;
}

signed char* read_file( FILE* file, size_t* n_chars ) {
    fseek (file, 0L, SEEK_END);
    long file_size = ftell (file);
    fseek (file, 0L, SEEK_SET);

    signed char *file_buffer = (signed char *)hc_malloc((1+file_size)*sizeof(signed char));

    size_t n_read_from_file = fread(file_buffer, sizeof(signed char), file_size, file);
    file_buffer[file_size] = '\n';

    /* shams' sample inputs have newlines in them */
    *n_chars = clear_whitespaces_do_mapping(file_buffer, file_size);
    return file_buffer;
}

int main ( int argc, char* argv[] ) { 
    int i, j;

	nthreads = hc_nproc();
    HCMPI_Comm_rank(HCMPI_COMM_WORLD, &comm_rank);
    HCMPI_Comm_size(HCMPI_COMM_WORLD, &comm_size);

	if (comm_rank == 0) {
		if ( argc < 7 ) {
			fprintf(stderr, "Usage: %s fileName1 fileName2 tileWidth tileHeight outerTileWidth outerTileHeight\n", argv[0]);
			HCMPI_Abort(HCMPI_COMM_WORLD, 1);
		}

		fprintf(stdout, "Running SmithWaterman (HCMPI) with %d processes, %d threads/process\n", comm_size, nthreads);

		char* file_name_1 = argv[1];
		char* file_name_2 = argv[2];

    	tile_width = (int) atoi (argv[3]);
    	tile_height = (int) atoi (argv[4]);
	
    	outer_tile_width = (int) atoi (argv[5]);
    	outer_tile_height = (int) atoi (argv[6]);
	
		FILE* file_1 = fopen(file_name_1, "r");
		if (!file_1) { fprintf(stderr, "could not open file %s\n",file_name_1); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }
		size_t n_char_in_file_1 = 0;
		string_1 = read_file(file_1, &n_char_in_file_1);
		fprintf(stdout, "Size of input string 1 is %u\n", (unsigned)n_char_in_file_1 );
	
		FILE* file_2 = fopen(file_name_2, "r");
		if (!file_2) { fprintf(stderr, "could not open file %s\n",file_name_2); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }
		size_t n_char_in_file_2 = 0;
		string_2 = read_file(file_2, &n_char_in_file_2);
		fprintf(stdout, "Size of input string 2 is %u\n", (unsigned)n_char_in_file_2 );
	
		fprintf(stdout, "Tile width  %d\n", tile_width);
		fprintf(stdout, "Tile height %d\n", tile_height);
	
		fprintf(stdout, "Outer Tile width  %d\n", outer_tile_width);
		fprintf(stdout, "Outer Tile height %d\n", outer_tile_height);
	
		if (n_char_in_file_1 % tile_width) { fprintf(stderr, "String1 length should be multiple of tile width\n"); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }
		if (n_char_in_file_2 % tile_height) { fprintf(stderr, "String2 length should be multiple of tile height\n"); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }

		if (n_char_in_file_1 % outer_tile_width) { fprintf(stderr, "String1 length should be multiple of outer tile width\n"); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }
		if (n_char_in_file_2 % outer_tile_height) { fprintf(stderr, "String2 length should be multiple of outer tile height\n"); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }

		if (outer_tile_width % tile_width) { fprintf(stderr, "Outer tile width should be multiple of tile width\n"); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }
		if (outer_tile_height % tile_height) { fprintf(stderr, "Outer tile height should be multiple of tile height\n"); HCMPI_Abort(HCMPI_COMM_WORLD, 1); }

		n_tiles_x = n_char_in_file_1/tile_width;
		n_tiles_y = n_char_in_file_2/tile_height;
	
		n_outer_tiles_x = n_char_in_file_1/outer_tile_width;
		n_outer_tiles_y = n_char_in_file_2/outer_tile_height;

		outer_tiles_length_x = outer_tile_width  / tile_width;
		outer_tiles_length_y = outer_tile_height / tile_height;

		int inner_diagonal = MIN(outer_tiles_length_x, outer_tiles_length_y);
		if (inner_diagonal < (nthreads-1)) { fprintf(stderr, "Warning: Insufficient intra-node parallelism\n"); }

		int outer_diagonal = MIN(n_outer_tiles_x, n_outer_tiles_y);
		if (outer_diagonal < comm_size) { fprintf(stderr, "Warning: Insufficient inter-node parallelism\n"); }
	
		fprintf(stdout, "Computing %d x %d intra-node tiles\n", n_tiles_x, n_tiles_y);
		fprintf(stdout, "Computing %d x %d inter-node tiles\n", n_outer_tiles_x, n_outer_tiles_y);

        strlen_1 = n_char_in_file_1;
        strlen_2 = n_char_in_file_2;
	}
	
    HCMPI_Bcast(&tile_width, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);
    HCMPI_Bcast(&tile_height, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);

    HCMPI_Bcast(&outer_tile_width, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);
    HCMPI_Bcast(&outer_tile_height, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);

    HCMPI_Bcast(&n_tiles_x, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);
    HCMPI_Bcast(&n_tiles_y, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);

    HCMPI_Bcast(&n_outer_tiles_x, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);
    HCMPI_Bcast(&n_outer_tiles_y, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);

    HCMPI_Bcast(&outer_tiles_length_x, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);
    HCMPI_Bcast(&outer_tiles_length_y, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);

    HCMPI_Bcast(&strlen_1, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);
    HCMPI_Bcast(&strlen_2, 1, HCMPI_INT, 0, HCMPI_COMM_WORLD);

    if ( comm_rank != 0 ) {
        string_1= (signed char*) hc_malloc(strlen_1 * sizeof(signed char));
        string_2= (signed char*) hc_malloc(strlen_2 * sizeof(signed char));
    }

    HCMPI_Bcast(string_1, strlen_1, HCMPI_CHAR, 0, HCMPI_COMM_WORLD);
    HCMPI_Bcast(string_2, strlen_2, HCMPI_CHAR, 0, HCMPI_COMM_WORLD);

#if DEBUG > 1
    if (comm_rank != 0) {
		fprintf(stdout, "Imported string1 length %d\n",strlen_1); 
		fprintf(stdout, "Imported string2 length %d\n",strlen_2); 
		fprintf(stdout, "Imported tile width  %d\n",tile_width); 
		fprintf(stdout, "Imported tile height %d\n",tile_height); 
		fprintf(stdout, "Imported %d x %d tiles\n",n_tiles_x, n_tiles_y); 
		fprintf(stdout, "Imported outer tile width  %d\n",outer_tile_width); 
		fprintf(stdout, "Imported outer tile height %d\n",outer_tile_height); 
		fprintf(stdout, "Imported %d x %d outer tiles\n",n_outer_tiles_x, n_outer_tiles_y); 
	}
	fflush(stdout);
	HCMPI_Barrier(HCMPI_COMM_WORLD);
#endif

	// Allocate space for edge data and diagonals

	// Increase tile space to allocate for initial condition
	n_tiles_x++;
	n_tiles_y++;

	// Allocate space for diagonal puts
	tile_diag = (int*)hc_malloc(sizeof(int)*(n_tiles_x + n_tiles_y - 1));
	tile_diag[DIAG_INDEX(0,0)] = 0;
	for (i = 1; i < n_tiles_x; i++)
		tile_diag[DIAG_INDEX(0,i)] = GAP_PENALTY*(i*tile_width);
	for (i = 1; i < n_tiles_y; i++)
		tile_diag[DIAG_INDEX(i,0)] = GAP_PENALTY*(i*tile_height);

	// Allocate space for x puts
	tile_edges_x = (int**)hc_malloc(sizeof(int*)*n_tiles_x);
	for (i = 1; i < n_tiles_x; i++) {
		tile_edges_x[i] = (int*)hc_malloc(sizeof(int)*(tile_width));
		for (j = 0; j < tile_width; j++)
			tile_edges_x[i][j] = GAP_PENALTY*((i-1)*tile_width+j);
	}

	// Allocate space for y puts
	tile_edges_y = (int**)hc_malloc(sizeof(int*)*n_tiles_y);
	for (i = 1; i < n_tiles_y; i++) {
		tile_edges_y[i] = (int*)hc_malloc(sizeof(int)*(tile_height));
		for (j = 0; j < tile_height; j++)
			tile_edges_y[i][j] = GAP_PENALTY*((i-1)*tile_height+j);
	}

	// Allocate working tile for each worker thread
	worker_tiles = (int***)hc_malloc(sizeof(int**)*nthreads);
	for (i = 0; i < nthreads; i++) {
		worker_tiles[i] = (int**)hc_malloc(sizeof(int*)*(tile_height+1));
		for (j = 0; j < tile_height+1; j++)
			worker_tiles[i][j] = (int*)hc_malloc(sizeof(int)*(tile_width+1));
	}

	// Setup DDF_SIZE
	dsizes[0] = sizeof(int);               //diag
	dsizes[1] = sizeof(int) * tile_height; //right column
	dsizes[2] = sizeof(int) * tile_width;  //bottom row

	// Allocate 2-D matrix of tile ddfs
#if DEBUG
	if (comm_rank == 0) {
		fprintf(stdout, "\nTile Matrix:\n\n     ");
		for ( j = 0; j < n_tiles_x; j++ )
			fprintf(stdout,"     %3d     ", j);
		fprintf(stdout,"\n     ");
		for ( j = 0; j < n_tiles_x; j++ )
			fprintf(stdout," ----------- ", j);
		fprintf(stdout,"\n\n");
	}
#endif

	tdfArray = (TDF_t ***)hc_malloc(sizeof(TDF_t**)*n_tiles_y);
	for ( i = 0; i < n_tiles_y; i++ ) {
		tdfArray[i] = (TDF_t **)hc_malloc(sizeof(TDF_t*)*(n_tiles_x));
		for ( j = 0; j < n_tiles_x; j++ ) {
			int diag_guid = DDDF_GUID_DIAG(i,j);
			int rcol_guid = DDDF_GUID_RCOL(i,j);
			int brow_guid = DDDF_GUID_BROW(i,j);
			assert(DDF_HOME(diag_guid) == DDF_HOME(rcol_guid));
			assert(DDF_HOME(diag_guid) == DDF_HOME(brow_guid));
			tdfArray[i][j] = (TDF_t *)hc_malloc(sizeof(TDF_t));
			tdfArray[i][j]->diag = DDF_HANDLE(diag_guid);
			tdfArray[i][j]->rcol = DDF_HANDLE(rcol_guid);
			tdfArray[i][j]->brow = DDF_HANDLE(brow_guid);
		}
#if DEBUG
		if (comm_rank == 0) {
			fprintf(stdout,"%3d |", i);
			for ( j = 0; j < n_tiles_x; j++ ) {
				int diag_guid = DDDF_GUID_DIAG(i,j);
				int rcol_guid = DDDF_GUID_RCOL(i,j);
				fprintf(stdout," [%4d %4d] ", DDF_HOME(diag_guid),rcol_guid);
			}
			fprintf(stdout,"\n     ");
			for ( j = 0; j < n_tiles_x; j++ ) {
				int diag_guid = DDDF_GUID_DIAG(i,j);
				int brow_guid = DDDF_GUID_BROW(i,j);
				fprintf(stdout," [%4d %4d] ", brow_guid,diag_guid);
			}
			fprintf(stdout,"\n\n");
		}
#endif
	}

	// Boundary data puts
	if (comm_rank == DDF_HOME(DDDF_GUID(0,0))) {
		DDF_PUT(tdfArray[0][0]->diag, &tile_diag[DIAG_INDEX(0,0)]);
	}

	for ( i = 1; i < n_tiles_x; i++ ) {
		if (comm_rank == DDF_HOME(DDDF_GUID(0,i))) {
			DDF_PUT(tdfArray[0][i]->brow, tile_edges_x[i]);
		}
		if (comm_rank == DDF_HOME(DDDF_GUID(0,i))) {
			DDF_PUT(tdfArray[0][i]->diag, &tile_diag[DIAG_INDEX(0,i)]);
		}
	}

	for ( i = 1; i < n_tiles_y; i++ ) {
		if (comm_rank == DDF_HOME(DDDF_GUID(i,0))) {
			DDF_PUT(tdfArray[i][0]->rcol, tile_edges_y[i]);
		}
		if (comm_rank == DDF_HOME(DDDF_GUID(i,0))) {
			DDF_PUT(tdfArray[i][0]->diag, &tile_diag[DIAG_INDEX(i, 0)]);
		}
	}

	int result_row = n_tiles_y - 1;
	int result_col = n_tiles_x - 1;
	int result_home = DDF_HOME(DDDF_GUID(result_row,result_col));

    if (comm_rank == result_home) {
    	gettimeofday(&begin,0);
	}

	finish {
		for ( i = 1; i < n_tiles_y; i++ ) {
			for ( j = 1; j < n_tiles_x; j++ ) {
				if (comm_rank == DDF_GET_HOME(tdfArray[i][j]->diag)) {
#if DEBUG > 2
fprintf(stdout,"[%d] Await: %d(%d)[%d] %d(%d)[%d] %d(%d)[%d]\n", comm_rank, DDDF_GUID_DIAG(i-1, j-1), ((DDDF_t*)(tdfArray[i-1][j-1]->diag))->global_id, DDF_HOME(DDDF_GUID_DIAG(i-1,j-1)),
																	        DDDF_GUID_BROW(i-1, j  ), ((DDDF_t*)(tdfArray[i-1][j  ]->brow))->global_id, DDF_HOME(DDDF_GUID_BROW(i-1,j  )),
																	        DDDF_GUID_RCOL(i  , j-1), ((DDDF_t*)(tdfArray[i  ][j-1]->rcol))->global_id, DDF_HOME(DDDF_GUID_RCOL(i  ,j-1)));
#endif
					async IN(i,j) AWAIT(tdfArray[i-1][j-1]->diag, tdfArray[i][j-1]->rcol, tdfArray[i-1][j]->brow) {
						int ii, jj;
						int ** local_matrix = worker_tiles[(current_ws())->id];

						int * tile_edge_x = DDF_GET(tdfArray[i-1][j  ]->brow);
						int * tile_edge_y = DDF_GET(tdfArray[i  ][j-1]->rcol);
                		int * diag        = DDF_GET(tdfArray[i-1][j-1]->diag);

                		local_matrix[0][0] = *diag;

                		for ( ii = 1; ii < tile_width+1; ++ii )
                    		local_matrix[0][ii] = tile_edge_x[ii-1];

                		for ( ii = 1; ii < tile_height+1; ++ii )
                    		local_matrix[ii][0] = tile_edge_y[ii-1];

                		for ( ii = 1; ii < tile_height+1; ++ii ) {
                    		for ( jj = 1; jj < tile_width+1; ++jj ) {
                        		signed char char_from_1 = string_1[(j-1)*tile_width+jj-1];
                        		signed char char_from_2 = string_2[(i-1)*tile_height+ii-1];

                        		int diag_score = local_matrix[ii-1][jj-1] + alignment_score_matrix[char_from_2][char_from_1];
                        		int left_score = local_matrix[ii  ][jj-1] + alignment_score_matrix[char_from_1][GAP];
                        		int  top_score = local_matrix[ii-1][jj  ] + alignment_score_matrix[GAP][char_from_2];

                        		int bigger_of_left_top = (left_score > top_score) ? left_score : top_score;
                        		local_matrix[ii][jj] = (bigger_of_left_top > diag_score) ? bigger_of_left_top : diag_score;
                    		}
                		}

						tile_edge_x =  tile_edges_x[j];
                		for ( ii = 1; ii < tile_width+1; ++ii )
                    		tile_edge_x[ii-1] = local_matrix[tile_height][ii];

						tile_edge_y =  tile_edges_y[i];
                		for ( ii = 1; ii < tile_height+1; ++ii )
                    		tile_edge_y[ii-1] = local_matrix[ii][tile_width];

                		tile_diag[DIAG_INDEX(i,j)] = local_matrix[tile_height][tile_width];

						DDF_PUT(tdfArray[i][j]->diag, &tile_diag[DIAG_INDEX(i,j)]);
						DDF_PUT(tdfArray[i][j]->rcol, tile_edge_y);
						DDF_PUT(tdfArray[i][j]->brow, tile_edge_x);

#if DEBUG > 1
						fprintf(stdout,"[%d] Tile[%d][%d] %d\n", comm_rank, i, j, local_matrix[tile_height][tile_width]);
#endif
#if DEBUG
						int brow_id = DDDF_GUID_BROW(i-1,j);
						int brow_home = (tdfArray[i-1][j]->brow->kind == DDF_KIND_DISTRIBUTED_REMOTE) ? ((DDDF_t*)(tdfArray[i-1][j]->brow))->home_rank : comm_rank;
						int func_brow = DDF_HOME(brow_id);
						if (brow_home != func_brow) { 
							fprintf(stderr, "[%d] Tile[%d][%d] DDF_HOME mismatch [%d][%d].brow (%d) %d Func %d\n",comm_rank, i, j, i-1, j, brow_id, brow_home, func_brow); 
							HCMPI_Abort(HCMPI_COMM_WORLD, 10); 
						}
						int rcol_id = DDDF_GUID_RCOL(i,j-1);
						int rcol_home = (tdfArray[i][j-1]->rcol->kind == DDF_KIND_DISTRIBUTED_REMOTE) ? ((DDDF_t*)(tdfArray[i][j-1]->rcol))->home_rank : comm_rank;
						int func_rcol = DDF_HOME(rcol_id);
						if (rcol_home != func_rcol) { 
							fprintf(stderr, "[%d] Tile[%d][%d] DDF_HOME mismatch [%d][%d].rcol (%d) %d Func %d\n",comm_rank, i, j, i-1, j, rcol_id, rcol_home, func_rcol); 
							HCMPI_Abort(HCMPI_COMM_WORLD, 10); 
						}
#endif
						// Free memory allocated for remote get
						if (comm_rank != DDF_GET_HOME(tdfArray[i-1][j]->brow))
							hc_free(DDF_GET(tdfArray[i-1][j]->brow));
						if (comm_rank != DDF_GET_HOME(tdfArray[i][j-1]->rcol))
							hc_free(DDF_GET(tdfArray[i][j-1]->rcol));
					}
				}
			}
		}

		async AWAIT(tdfArray[n_tiles_y-1][n_tiles_x-1]->diag); // Cheap implementation of distributed finish :-) Wait for last tile completion
	}

    if (comm_rank == result_home) {
    	gettimeofday(&end,0);
    	int score = tile_diag[DIAG_INDEX(result_row,result_col)];
    	fprintf(stdout, "score: %d\n", score);
    	fprintf(stdout, "The computation took %f seconds\n",((end.tv_sec - begin.tv_sec)*1000000+(end.tv_usec - begin.tv_usec))*1.0/1000000);
	}

	for (i = 0; i < nthreads; i++) {
		for (j = 0; j < tile_height+1; j++)
			hc_free(worker_tiles[i][j]);
		hc_free(worker_tiles[i]);
	}
	hc_free(worker_tiles);

	for (i = 1; i < n_tiles_y; i++)
		hc_free(tile_edges_y[i]);
	hc_free(tile_edges_y);

	for (i = 1; i < n_tiles_x; i++)
		hc_free(tile_edges_x[i]);
	hc_free(tile_edges_x);

	hc_free(tile_diag);

	for ( i = 0; i < n_tiles_y; i++ ) {
		for ( j = 0; j < n_tiles_x; j++ )
			hc_free(tdfArray[i][j]);
		hc_free(tdfArray[i]);
	}
	hc_free(tdfArray);

	hc_free(string_1);
	hc_free(string_2);

    return 0;
}


