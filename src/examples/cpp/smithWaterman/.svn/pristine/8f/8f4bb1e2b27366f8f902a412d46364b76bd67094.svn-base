/*
author: sagnak tasirlar (sagnak@rice.edu)
implementation of the smith waterman sequence alignment for proof of concept not performance
*/

#include "stdio.h"
#include "stdlib.h"
#include <hc.h>

#define BUFSIZE 6
#define LOG_WORKLOAD 20
//-1 -2 -4 2
#define GAP_PENALTY -1 
#define TRANSITION_PENALTY -1
#define TRANSVERSION_PENALTY -1
#define MATCH 2

#define CELL_VALUE_T short 
#define BOX_CELL_VALUE_T BoxShort 

enum Nucleotide {Gap, Adenine, Cytosine, Guanine, Thymine};

typedef struct BoxShort {
		  short value;
} BoxShort;

typedef struct Cell {
		  DDF_t* value;
		  DDF_t* valueFromAbove;
		  DDF_t* valueFromLeft;
		  DDF_t* valueFromDiagonal;
} Cell;

void constructCell( Cell* passedCell ) {
		  passedCell->value = DDF_CREATE();
		  passedCell->valueFromAbove = DDF_CREATE();
		  passedCell->valueFromLeft = DDF_CREATE();
		  passedCell->valueFromDiagonal = DDF_CREATE();
}

void computeCell ( Cell* passedCell ) {
		  int i = 0;
		  int bigger = 0;
		  BOX_CELL_VALUE_T * max = NULL;
		  double x[1];

		  CELL_VALUE_T above = ((BOX_CELL_VALUE_T *) DDF_GET(passedCell->valueFromAbove))->value;
		  CELL_VALUE_T left  = ((BOX_CELL_VALUE_T *) DDF_GET(passedCell->valueFromLeft))->value;
		  CELL_VALUE_T diag  = ((BOX_CELL_VALUE_T *) DDF_GET(passedCell->valueFromDiagonal))->value;

		  x[0] = 1;
		  // Dummy computation to obtain useful timing measurements
		  for (i = 0 ; i < (1 << LOG_WORKLOAD); ++i) x[0] = x[0]*x[0];

		  bigger = (left > diag) ? left : diag;
		  bigger = (above > bigger) ? above : bigger;
		  max = (BOX_CELL_VALUE_T *)hc_malloc(sizeof(BOX_CELL_VALUE_T));
		  max->value = bigger;
		  DDF_PUT(passedCell->value, max);
}

enum Nucleotide getIndex (char passedChar) {
		  enum Nucleotide toBeReturned;
		  switch(passedChar) {
					 case '_': toBeReturned = Gap; break;
					 case 'A': toBeReturned = Adenine; break;
					 case 'C': toBeReturned = Cytosine; break;
					 case 'G': toBeReturned = Guanine; break;
					 case 'T': toBeReturned = Thymine; break;
		  }
		  return toBeReturned;
}

typedef struct AlignmentMatrix {
		  int height;
		  int width;

		  char* alignString1;
		  char* alignString2;

		  char alignmentScoreMatrix[5][5];

		  Cell ** matrix;
} AlignmentMatrix;

BOX_CELL_VALUE_T* alignmentGapCharScore (AlignmentMatrix* alignment, char c2) {
		  BOX_CELL_VALUE_T* box = (BOX_CELL_VALUE_T*) hc_malloc(sizeof(BOX_CELL_VALUE_T));
		  box->value = alignment->alignmentScoreMatrix[Gap][getIndex(c2)]; 
		  return box;
}

BOX_CELL_VALUE_T* alignmentCharGapScore (AlignmentMatrix* alignment, char c1) {
		  BOX_CELL_VALUE_T* box = (BOX_CELL_VALUE_T*) hc_malloc(sizeof(BOX_CELL_VALUE_T));
		  box->value = alignment->alignmentScoreMatrix[getIndex(c1)][Gap];
		  return box;
}

BOX_CELL_VALUE_T* alignmentCharCharScore (AlignmentMatrix* alignment, char c1, char c2) {
		  BOX_CELL_VALUE_T* box = (BOX_CELL_VALUE_T*) hc_malloc(sizeof(BOX_CELL_VALUE_T));
		  box->value = alignment->alignmentScoreMatrix[getIndex(c1)][getIndex(c2)];
		  return box;
}

void initializeBorders ( AlignmentMatrix* alignment ) {
		  int i = 0;
		  int j = 0;

		  int height = alignment->height;
		  int width = alignment->width;

		  char* alignString1 = alignment->alignString1;
		  char* alignString2 = alignment->alignString2;

		  Cell** matrix = alignment->matrix;

		  DDF_PUT(matrix[1][1].valueFromDiagonal, alignmentCharCharScore(alignment, alignString1[0],alignString2[0])); 

		  for ( i = 1; i < height - 1; ++i ) {
					 DDF_PUT(matrix[i][1].valueFromLeft, alignmentGapCharScore (alignment, alignString2[0])); 
					 DDF_PUT(matrix[i+1][1].valueFromDiagonal, alignmentCharCharScore(alignment, alignString1[i],alignString2[0])); 
		  }
		  DDF_PUT(matrix[height-1][1].valueFromLeft, alignmentGapCharScore (alignment,alignString2[0])); 

		  for ( j = 1; j < width - 1; ++j ) {
					 DDF_PUT(matrix[1][j].valueFromAbove, alignmentCharGapScore(alignment, alignString1[0]));
					 DDF_PUT(matrix[1][j+1].valueFromDiagonal, alignmentCharCharScore(alignment,alignString1[0],alignString2[j]));
		  }
		  DDF_PUT(matrix[1][width-1].valueFromAbove, alignmentCharGapScore(alignment, alignString1[0]));
}

AlignmentMatrix* createAlignmentMatrix( int strlen1, char* passedAlignString1, int strlen2, char* passedAlignString2 ) {
		  int i = 0; 
		  int j = 0; 

		  AlignmentMatrix* alignment = (AlignmentMatrix*)hc_malloc(sizeof(AlignmentMatrix));
		  for ( i = 0; i < 5; ++i ) alignment->alignmentScoreMatrix[i][0] = alignment->alignmentScoreMatrix[0][i] = GAP_PENALTY;
		  for ( i = 1; i < 5; ++i ) alignment->alignmentScoreMatrix[i][i] = MATCH;
		  for ( i = 1; i < 4; ++i ) alignment->alignmentScoreMatrix[i+1][i] = alignment->alignmentScoreMatrix[i][i+1] = TRANSVERSION_PENALTY;
		  for ( i = 1; i < 3; ++i ) alignment->alignmentScoreMatrix[i+2][i] = alignment->alignmentScoreMatrix[i][i+2] = TRANSITION_PENALTY;
		  for ( i = 1; i < 2; ++i ) alignment->alignmentScoreMatrix[i+3][i] = alignment->alignmentScoreMatrix[i][i+3] = TRANSVERSION_PENALTY;
					 
		  // uncomment to see your alignment score matrix
		  // for (i = 0; i < 5; ++i, printf("\n") ) for (j = 0; j < 5; ++j ) printf("%d ", alignment->alignmentScoreMatrix[i][j]);

		  alignment->alignString1 = passedAlignString1;
		  alignment->alignString2 = passedAlignString2;

		  alignment->height = strlen1+1;
		  alignment->width = strlen2+1;

		  alignment->matrix = (Cell**)hc_malloc(sizeof(Cell*)*(alignment->height+1));
		  for ( i = 0; i < alignment->height; ++i ) {
					 alignment->matrix[i] = (Cell*)hc_malloc(sizeof(Cell)*alignment->width);
					 for ( j = 0; j < alignment->width; ++j ) {
								constructCell(&(alignment->matrix[i][j]));
					 }
		  }
		  initializeBorders(alignment);
		  return alignment;
}

int main ( int argc, char** argv ) {
		  char* fileName1 = NULL;
		  char* fileName2 = NULL;

		  int string1Size = -1;
		  int string2Size = -1;

		  FILE* file1 = NULL;
		  FILE* file2 = NULL;

		  char* my_buffer = NULL;
		  char* string1Buffer = NULL;
		  char* string2Buffer = NULL;

        if (argc == 3){
            fileName1 = argv[1];
            fileName2 = argv[2];
        }  else {
            fprintf(stderr, "Usage: ./SmithWaterman fileName1 fileName2\n");
            return 1;
        }

		  file1 = fopen(fileName1,"r");
		  if (!file1) { fprintf(stderr, "could not open file %s\n",fileName1); return 1; }
		  file2 = fopen(fileName2,"r");
		  if (!file2) { fprintf(stderr, "could not open file %s\n",fileName2); return 1; }

		  my_buffer = (char*) hc_malloc(sizeof(char)*BUFSIZE);
		  fgets(my_buffer,BUFSIZE,file1);
		  string1Size = atoi(my_buffer);
		  fgets(my_buffer,BUFSIZE,file2);
		  string2Size = atoi(my_buffer);

		  string1Buffer = hc_malloc(sizeof(char)*(string1Size+1));
		  fgets(string1Buffer, string1Size+1, file1);
		  string2Buffer = hc_malloc(sizeof(char)*(string2Size+1));
		  fgets(string2Buffer, string2Size+1, file2);

		  AlignmentMatrix* m = createAlignmentMatrix( string1Size, string1Buffer, string2Size, string2Buffer );
		  finish {
					 int i = 0, j = 0;
					 for ( i = 1; i < m->height ; ++i ) {
								for ( j = 1; j < m->width; ++j ) {
										  Cell* curr = &(m->matrix[i][j]);
										  async IN(m,i,j,curr) AWAIT (curr->valueFromAbove, curr->valueFromLeft, curr->valueFromDiagonal) {
													 computeCell(curr);
													 async IN(m,curr,i,j) AWAIT (curr->value) {
																BOX_CELL_VALUE_T* aboveValue, *alignValue, *leftValue;
																CELL_VALUE_T currValue = ((BOX_CELL_VALUE_T*)DDF_GET(curr->value))->value;

																if ( i < m->height-1 ) {
																		  aboveValue = alignmentCharGapScore(m, m->alignString1[i]);
																		  aboveValue->value += currValue;
																		  DDF_PUT( m->matrix[i+1][j].valueFromAbove, aboveValue );
																		  if ( j < m->width -1 ) { 
																					 alignValue = alignmentCharCharScore(m, m->alignString1[i], m->alignString2[j]);
																					 alignValue ->value += currValue;
																					 DDF_PUT(m->matrix[i+1][j+1].valueFromDiagonal, alignValue);
																		  }
																}
																if ( j < m->width -1) {
																		  leftValue = alignmentGapCharScore (m, m->alignString2[j]);
																		  leftValue->value += currValue;
																		  DDF_PUT(m->matrix[i][j+1].valueFromLeft, leftValue);
																}
													 }
										  }
								}
					 }
		  }
		  printf("Alignment score is: %d\n", ((BOX_CELL_VALUE_T*)(DDF_GET(m->matrix[m->height-1][m->width-1].value)))->value);

		  /* uncomment to see your score matrix
			  int i, j;
			  for (i = 1; i < m->height; ++i ) {
			  for (j = 1; j < m->width; ++j )
			  printf("%d ", ((BOX_CELL_VALUE_T*)(DDF_GET(m->matrix[i][j].value)))->value);
			  printf("\n");
			  }
		*/
		  return 0;
}
