#include <stdio.h>
#include <hc.h>
#include <sys/time.h>
#include <time.h>

#define GAP_PENALTY -1
#define TRANSITION_PENALTY -2
#define TRANSVERSION_PENALTY -4
#define MATCH 2

enum Nucleotide {GAP=0, ADENINE, CYTOSINE, GUANINE, THYMINE};

signed char char_mapping ( char c ) {
    signed char to_be_returned = -1;
    switch(c) {
        case '_': to_be_returned = GAP; break;
        case 'A': to_be_returned = ADENINE; break;
        case 'C': to_be_returned = CYTOSINE; break;
        case 'G': to_be_returned = GUANINE; break;
        case 'T': to_be_returned = THYMINE; break;
    }
    return to_be_returned;
}

void print_matrix ( int** matrix, int n_rows, int n_columns ) {
    int i, j;
    for ( i = 0; i < n_rows; ++i ) {
        for ( j = 0; j < n_columns; ++j ) {
            fprintf(stdout, "%d ", matrix[i][j]);
        }
        fprintf(stdout, "\n");
    }
    fprintf(stdout,"--------------------------------\n");
}

static char alignment_score_matrix[5][5] =
{
    {GAP_PENALTY,GAP_PENALTY,GAP_PENALTY,GAP_PENALTY,GAP_PENALTY},
    {GAP_PENALTY,MATCH,TRANSVERSION_PENALTY,TRANSITION_PENALTY,TRANSVERSION_PENALTY},
    {GAP_PENALTY,TRANSVERSION_PENALTY, MATCH,TRANSVERSION_PENALTY,TRANSITION_PENALTY},
    {GAP_PENALTY,TRANSITION_PENALTY,TRANSVERSION_PENALTY, MATCH,TRANSVERSION_PENALTY},
    {GAP_PENALTY,TRANSVERSION_PENALTY,TRANSITION_PENALTY,TRANSVERSION_PENALTY, MATCH}
};

size_t clear_whitespaces_do_mapping ( signed char* buffer, long size ) {
    size_t non_ws_index = 0, traverse_index = 0;

    while ( traverse_index < size ) {
        char curr_char = buffer[traverse_index];
        switch ( curr_char ) {
            case 'A': case 'C': case 'G': case 'T':
                /*this used to be a copy not also does mapping*/
                buffer[non_ws_index++] = char_mapping(curr_char);
                break;
        }
        ++traverse_index;
    }
    return non_ws_index;
}

signed char* read_file( FILE* file, size_t* n_chars ) {
    fseek (file, 0L, SEEK_END);
    long file_size = ftell (file);
    fseek (file, 0L, SEEK_SET);

    signed char *file_buffer = (signed char *)hc_malloc((1+file_size)*sizeof(signed char));

    size_t n_read_from_file = fread(file_buffer, sizeof(signed char), file_size, file);
    file_buffer[file_size] = '\n';

    /* shams' sample inputs have newlines in them */
    *n_chars = clear_whitespaces_do_mapping(file_buffer, file_size);
    return file_buffer;
}

typedef struct {
    DDF_t* bottom_row;
    DDF_t* right_column;
    DDF_t* bottom_right;
} Inner_Tile_t;

typedef struct {
    DDF_t* bottom_row;
    DDF_t* right_column;
    DDF_t* bottom_right;
} Outer_Tile_t;


int main ( int argc, char* argv[] ) {

    int i, j;

    int outer_tile_width = (int) atoi (argv[3]);
    int outer_tile_height = (int) atoi (argv[4]);

    int inner_tile_width = (int) atoi (argv[5]);
    int inner_tile_height = (int) atoi (argv[6]);

    int n_outer_tiles_width;
    int n_outer_tiles_height;

    int n_inner_tiles_width = outer_tile_width / inner_tile_width;
    int n_inner_tiles_height = outer_tile_height / inner_tile_height;

    if ( argc < 7 ) {
        fprintf(stderr, "Usage: %s fileName1 fileName2 outerTileWidth outerTileHeight innerTileWidth innerTileHeight\n", argv[0]);
        exit(1);
    }

    if ( outer_tile_width % inner_tile_width != 0 ) {
        fprintf(stderr, "Outer tile width: %d, should be a multiple of inner tile width: %d", outer_tile_width, inner_tile_width);
        exit(1);
    }

    if ( outer_tile_height % inner_tile_height != 0 ) {
        fprintf(stderr, "Outer tile height: %d, should be a multiple of inner tile height: %d", outer_tile_height, inner_tile_height);
        exit(1);
    }

    signed char* string_1;
    signed char* string_2;

    char* file_name_1 = argv[1];
    char* file_name_2 = argv[2];

    FILE* file_1 = fopen(file_name_1, "r");
    if (!file_1) { fprintf(stderr, "could not open file %s\n",file_name_1); exit(1); }
    size_t n_char_in_file_1 = 0;
    string_1 = read_file(file_1, &n_char_in_file_1);
    fprintf(stdout, "Size of input string 1 is %u\n", n_char_in_file_1 );

    FILE* file_2 = fopen(file_name_2, "r");
    if (!file_2) { fprintf(stderr, "could not open file %s\n",file_name_2); exit(1); }
    size_t n_char_in_file_2 = 0;
    string_2 = read_file(file_2, &n_char_in_file_2);
    fprintf(stdout, "Size of input string 2 is %u\n", n_char_in_file_2 );

    fprintf(stdout, "Outer tile width is %d\n", outer_tile_width);
    fprintf(stdout, "Outer tile height is %d\n", outer_tile_height);

    fprintf(stdout, "Inner tile width is %d\n", inner_tile_width);
    fprintf(stdout, "Inner tile height is %d\n", inner_tile_height);

    n_outer_tiles_width = n_char_in_file_1/outer_tile_width;
    n_outer_tiles_height = n_char_in_file_2/outer_tile_height;

    fprintf(stdout, "Imported %d x %d tiles.\n", n_outer_tiles_width, n_outer_tiles_height);

    fprintf(stdout, "Allocating tile matrix\n");

    // sagnak: all workers allocate their own copy of tile matrix
    Outer_Tile_t** outer_tile_matrix = (Outer_Tile_t **) hc_malloc(sizeof(Outer_Tile_t*)*(n_outer_tiles_height+1)); 
    for ( i = 0; i < n_outer_tiles_height+1; ++i ) {
        outer_tile_matrix[i] = (Outer_Tile_t *) hc_malloc(sizeof(Outer_Tile_t)*(n_outer_tiles_width+1));
        for ( j = 0; j < n_outer_tiles_width+1; ++j ) {
            outer_tile_matrix[i][j].bottom_row = DDF_CREATE();
            outer_tile_matrix[i][j].right_column = DDF_CREATE();
            outer_tile_matrix[i][j].bottom_right = DDF_CREATE();
        }
    }

    fprintf(stdout, "Allocated tile matrix\n");

    int* allocated = (int*)hc_malloc(sizeof(int));
    allocated[0] = 0;
    DDF_PUT(outer_tile_matrix[0][0].bottom_right, allocated);

    for ( j = 1; j < n_outer_tiles_width + 1; ++j ) {
        allocated = (int*)hc_malloc(sizeof(int)*outer_tile_width);
        for( i = 0; i < outer_tile_width ; ++i ) {
            allocated[i] = GAP_PENALTY*((j-1)*outer_tile_width+i+1);
        }
        DDF_PUT(outer_tile_matrix[0][j].bottom_row, allocated);

        allocated = (int*)hc_malloc(sizeof(int));
        allocated[0] = GAP_PENALTY*(j*outer_tile_width); //sagnak: needed to handle tilesize 2
        DDF_PUT(outer_tile_matrix[0][j].bottom_right, allocated);
    }

    for ( i = 1; i < n_outer_tiles_height + 1; ++i ) {
        allocated = (int*)hc_malloc(sizeof(int)*outer_tile_height);
        for ( j = 0; j < outer_tile_height ; ++j ) {
            allocated[j] = GAP_PENALTY*((i-1)*outer_tile_height+j+1);
        }
        DDF_PUT(outer_tile_matrix[i][0].right_column, allocated);

        allocated = (int*)hc_malloc(sizeof(int));
        allocated[0] = GAP_PENALTY*(i*outer_tile_height); //sagnak: needed to handle tilesize 2
        DDF_PUT(outer_tile_matrix[i][0].bottom_right, allocated);
    }


    struct timeval begin,end;
    gettimeofday(&begin,0);

    finish {
        for ( i = 1; i < n_outer_tiles_height+1; ++i ) {
            for ( j = 1; j < n_outer_tiles_width+1; ++j ) {
                    async IN(i,j,outer_tile_width,outer_tile_height,inner_tile_width,inner_tile_height,n_inner_tiles_width,n_inner_tiles_height,outer_tile_matrix,string_1,string_2) AWAIT ( outer_tile_matrix[i][j-1].right_column, outer_tile_matrix[i-1][j].bottom_row, outer_tile_matrix[i-1][j-1].bottom_right ) {
                        int* left_tile_right_column = (int *) DDF_GET(outer_tile_matrix[  i][j-1].right_column); 
                        int* above_tile_bottom_row = (int *) DDF_GET(outer_tile_matrix[i-1][j  ].bottom_row);
                        int* p_diagonal = (int *) DDF_GET(outer_tile_matrix[i-1][j-1].bottom_right);

                        int k, ii, jj;
                        int* allocated;

                        /****************************************************/

                        Inner_Tile_t * tile_tmp = (Inner_Tile_t*) hc_malloc(sizeof(Inner_Tile_t)*(1+n_inner_tiles_width)*(1+n_inner_tiles_height));
                        Inner_Tile_t ** inner_tile_matrix = (Inner_Tile_t**)hc_malloc(sizeof(Inner_Tile_t*)*(1+n_inner_tiles_height));
                        for (k = 0; k < n_inner_tiles_height+1; ++k) 
                            inner_tile_matrix[k] = &tile_tmp[k * (1+n_inner_tiles_width)];

                        for ( ii = 0; ii < n_inner_tiles_height+1; ++ii ) {
                            for ( jj = 0; jj < n_inner_tiles_width+1; ++jj ) {
                                inner_tile_matrix[ii][jj].bottom_row = DDF_CREATE();
                                inner_tile_matrix[ii][jj].right_column = DDF_CREATE();
                                inner_tile_matrix[ii][jj].bottom_right = DDF_CREATE();
                            }
                        }

                        allocated = (int*)hc_malloc(sizeof(int));
                        allocated[0] = p_diagonal[0];
                        DDF_PUT(inner_tile_matrix[0][0].bottom_right, allocated);
                        hc_free(p_diagonal);

                        k = 0;
                        for ( jj = 1; jj < n_inner_tiles_width + 1; ++jj ) {
                            allocated = (int*)hc_malloc(sizeof(int)*inner_tile_width);
                            for( ii = 0; ii < inner_tile_width ; ++ii ) {
                                allocated[ii] = above_tile_bottom_row[k++];
                            }
                            DDF_PUT(inner_tile_matrix[0][jj].bottom_row, allocated);

                            int* inner_allocated = (int*)hc_malloc(sizeof(int));
                            inner_allocated[0] = allocated[inner_tile_width-1];
                            DDF_PUT(inner_tile_matrix[0][jj].bottom_right, inner_allocated);
                        }
                        hc_free(above_tile_bottom_row);

                        k = 0;
                        for ( ii = 1; ii < n_inner_tiles_height + 1; ++ii ) {
                            allocated = (int*)hc_malloc(sizeof(int)*inner_tile_height);
                            for ( jj = 0; jj < inner_tile_height ; ++jj ) {
                                allocated[jj] = left_tile_right_column[k++];
                            }
                            DDF_PUT(inner_tile_matrix[ii][0].right_column, allocated);

                            int* inner_allocated = (int*)hc_malloc(sizeof(int));
                            inner_allocated[0] = allocated[inner_tile_height-1];
                            DDF_PUT(inner_tile_matrix[ii][0].bottom_right, inner_allocated);
                        }
                        hc_free(left_tile_right_column);

                        int iii, jjj;
                        finish {
                            for ( ii = 1; ii < n_inner_tiles_height + 1; ++ii ) {
                                for ( jj = 1; jj < n_inner_tiles_width + 1; ++jj ) {
                                    async IN(inner_tile_matrix, inner_tile_width, inner_tile_height, outer_tile_width, outer_tile_height, n_inner_tiles_width, n_inner_tiles_height, string_1, string_2, k, i,j, ii,jj, iii,jjj) AWAIT(inner_tile_matrix[ii-1][jj].bottom_row, inner_tile_matrix[ii][jj-1].right_column, inner_tile_matrix[ii-1][jj-1].bottom_right ) {

                                        int  * curr_tile_tmp = (int*) hc_malloc(sizeof(int)*(1+inner_tile_width)*(1+inner_tile_height));
                                        int ** curr_tile = (int**) hc_malloc(sizeof(int*)*(1+inner_tile_height));
                                        for (k = 0; k < inner_tile_height+1; ++k) {
                                            curr_tile[k] = &curr_tile_tmp[k*(1+inner_tile_width)];
                                        }

                                        int* above_inner_tile_bottom_row = (int*)DDF_GET(inner_tile_matrix[ii-1][jj].bottom_row);
                                        int* left_inner_tile_right_column = (int*)DDF_GET(inner_tile_matrix[ii][jj-1].right_column);
                                        int* diagonal_inner_tile_bottom_right = (int*)DDF_GET(inner_tile_matrix[ii-1][jj-1].bottom_right);

                                        curr_tile[0][0] = diagonal_inner_tile_bottom_right[0];
                                        for ( iii = 1; iii < inner_tile_height+1; ++iii ) {
                                            curr_tile[iii][0] = left_inner_tile_right_column[iii-1];
                                        }

                                        for ( jjj = 1; jjj < inner_tile_width+1; ++jjj ) {
                                            curr_tile[0][jjj] = above_inner_tile_bottom_row[jjj-1];
                                        }

                                        for ( iii = 1; iii < inner_tile_height+1; ++iii ) {
                                            for ( jjj = 1; jjj < inner_tile_width+1; ++jjj ) {
                                                signed char char_from_1 = string_1[(j-1)*outer_tile_width+(jj-1)*inner_tile_width + jjj-1];
                                                signed char char_from_2 = string_2[(i-1)*outer_tile_height+(ii-1)*inner_tile_height + iii-1];

                                                int diag_score = curr_tile[iii-1][jjj-1] + alignment_score_matrix[char_from_2][char_from_1];
                                                int left_score = curr_tile[iii  ][jjj-1] + alignment_score_matrix[char_from_1][GAP];
                                                int  top_score = curr_tile[iii-1][jjj  ] + alignment_score_matrix[GAP][char_from_2];

                                                int bigger_of_left_top = (left_score > top_score) ? left_score : top_score;
                                                curr_tile[iii][jjj] = (bigger_of_left_top > diag_score) ? bigger_of_left_top : diag_score;
                                            }
                                        }

                                        int* curr_bottom_right = (int*)hc_malloc(sizeof(int));
                                        curr_bottom_right[0] = curr_tile[inner_tile_height][inner_tile_width];
                                        DDF_PUT(inner_tile_matrix[ii][jj].bottom_right, curr_bottom_right);

                                        int* curr_right_column = (int*)hc_malloc(sizeof(int)*inner_tile_height);
                                        for ( iii = 0; iii < inner_tile_height; ++iii ) {
                                            curr_right_column[iii] = curr_tile[iii+1][inner_tile_width];
                                        }
                                        DDF_PUT(inner_tile_matrix[ii][jj].right_column, curr_right_column);

                                        int* curr_bottom_row = (int*)hc_malloc(sizeof(int)*inner_tile_width);
                                        for ( jjj = 0; jjj < inner_tile_width; ++jjj ) {
                                            curr_bottom_row[jjj] = curr_tile[inner_tile_height][jjj+1];
                                        }
                                        DDF_PUT(inner_tile_matrix[ii][jj].bottom_row, curr_bottom_row);

                                        hc_free(curr_tile);
                                        hc_free(curr_tile_tmp);
                                    }
                                }
                            }
                        }

                        allocated = (int*) hc_malloc (sizeof(int)*outer_tile_height);
                        k = 0;
                        for ( ii = 1; ii < n_inner_tiles_height + 1; ++ii ) {
                            int * curr_tile_right_column = (int*) DDF_GET(inner_tile_matrix[ii][n_inner_tiles_width].right_column);
                            for ( iii = 1; iii < inner_tile_height+1; ++iii ) {
                                allocated[k++] = curr_tile_right_column[iii-1]; 
                            }
                        }
                        DDF_PUT(outer_tile_matrix[i][j].right_column, allocated);

                        allocated = (int*) hc_malloc (sizeof(int)*outer_tile_width);
                        k = 0;
                        for ( jj = 1; jj < n_inner_tiles_width + 1; ++jj ) {
                            int * curr_tile_bottom_row = (int*) DDF_GET(inner_tile_matrix[n_inner_tiles_height][jj].bottom_row);
                            for ( jjj = 1; jjj < inner_tile_width+1; ++jjj ) {
                                allocated[k++] = curr_tile_bottom_row [jjj-1]; 
                            }
                        }
                        DDF_PUT(outer_tile_matrix[i][j].bottom_row, allocated);

                        allocated = (int*) DDF_GET(inner_tile_matrix[n_inner_tiles_height][n_inner_tiles_width].bottom_right);
                        DDF_PUT(outer_tile_matrix[i][j].bottom_right, allocated);

                        for ( ii = 0; ii < n_inner_tiles_height+1; ++ii ) {
                            for ( jj = 0; jj < n_inner_tiles_width+1; ++jj ) {
                                hc_free(inner_tile_matrix[ii][jj].bottom_row);
                                hc_free(inner_tile_matrix[ii][jj].right_column);
                                hc_free(inner_tile_matrix[ii][jj].bottom_right);
                            }
                        }

                        hc_free(tile_tmp);
                        hc_free(inner_tile_matrix);

                        /****************************************************/
                    }
            }
        }
    }

    gettimeofday(&end,0);
    fprintf(stdout, "The computation took %f seconds\n",((end.tv_sec - begin.tv_sec)*1000000+(end.tv_usec - begin.tv_usec))*1.0/1000000);

    int score = ((int *)DDF_GET(outer_tile_matrix[n_outer_tiles_height][n_outer_tiles_width].bottom_row))[outer_tile_width-1];
    fprintf(stdout, "score: %d\n", score);

    return 0;
}
